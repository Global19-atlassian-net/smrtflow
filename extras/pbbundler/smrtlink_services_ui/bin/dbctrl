#!/usr/bin/env python
import argparse
import logging
import os
import subprocess
import sys
import json
import tempfile
import datetime
from collections import namedtuple

__version__ = "0.1.0"
__author__ = "mkocher"

log = logging.getLogger(__name__)

_BIN_DIR = os.path.abspath(os.path.dirname(__file__))
_BUNDLE_ROOT = os.path.dirname(_BIN_DIR)
# Admin tools
_TOOLS_DIR = os.path.join(_BUNDLE_ROOT, "tools/bin")

_SL_CONFIG = os.path.join(_BUNDLE_ROOT, "smrtlink-system-config.json")
# Migration State file
_MIGRATION_JSON = os.path.join(_BUNDLE_ROOT, "legacy-migration.json")

DbConfig = namedtuple("DbConfig", "db_name, pg_data_dir, host, port, user, password")


class Migration(object):
    def __init__(self, was_successful, updated_at, db_path, comment):
        # should this have more than one state?
        self.was_successful = was_successful
        self.updated_at = updated_at
        self.db_path = db_path
        self.comment = comment

    def __repr__(self):
        _d = dict(s=self.was_successful, u=self.updated_at,
                  p=self.db_path, k=self.__class__.__name__)
        return "<{k} successful:{s} updated at:{u} sqlite:{p} >".format(**_d)

    def to_dict(self):

        _d = dict(was_successful=self.was_successful,
                  updated_at=str(self.updated_at),
                  db_path=self.db_path,
                  comment=self.comment)
        return _d

    @staticmethod
    def from_d(d):
        return Migration(d['was_successful'], d['updated_at'], d['db_path'], d['comment'])

    def write(self, output_file):
        d = self.to_dict()
        with open(output_file, 'w+') as f:
            f.write(json.dumps(d, indent=4, sort_keys=True))
        return d


def subparser_builder(subparser, subparser_id, description, options_func, exe_func):
    p = subparser.add_parser(subparser_id, help=description)
    options_func(p)
    p.set_defaults(func=exe_func)
    return p


def get_parser():
    desc = "Tool to interact with Postgres 9.6.x"
    p = argparse.ArgumentParser(version=__version__,
                                description=desc,
                                formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    def base_opts(p_):
        f = p_.add_argument
        f('-c', "--config", help="Path to smrtlink-system-config.json", default=_SL_CONFIG)
        f('--log-file', help="Log file")
        f('--log-level', default=logging.INFO, help="Log level when emitting to a log file")
        return p_

    sp = p.add_subparsers(help='commands')

    def builder(subparser_id, description, options_func, exe_func):
        subparser_builder(sp, subparser_id, description, options_func, exe_func)

    def migrate_opts(px):
        base_opts(px)
        px.add_argument('-s', '--sqlite-path', help="Path to SL >= 4.0.0 Sqlite file")
        px.add_argument('-m', '--legacy-migration', help="Path to Legacy Migration JSON file", default=_MIGRATION_JSON)
        return px

    def args_db_status(args):
        return db_status(load_db_config(args.config))

    def args_db_start(args):
        return db_start(load_db_config(args.config))

    def args_db_stop(args):
        return db_stop(load_db_config(args.config))

    def args_db_init(args):
        return db_init(load_db_config(args.config))

    def args_db_create(args):
        return db_create(load_db_config(args.config))

    def args_db_migrate(args):
        return db_migrate(load_db_config(args.config), args.sqlite_path, args.legacy_migration)

    desc_init = "Initialize database server (will start up db and shutdown after initialization)"
    desc_create = "Create SL database (init must be called first)"
    desc_migrate = "Import SL >= 4.0.0 SQLite into Postgres"

    builder("status", "Get status of the database", base_opts, args_db_status)
    builder("start", "Start database server", base_opts, args_db_start)
    builder("stop", "Stop Database server", base_opts, args_db_stop)
    builder("init", desc_init, base_opts, args_db_init)
    builder("create", desc_create, base_opts, args_db_create)
    builder("migrate", desc_migrate, migrate_opts, args_db_migrate)

    return p


def load_db_config(path):
    """Load the DB config from the smrtlink-system-config.json"""

    d = json.load(open(path, 'r'))

    def to_a(sx):
        return sx.encode("utf8", "ignore")

    db_name = to_a(d['smrtflow']['db']['properties']['databaseName'])

    pg_data_dir = os.path.join(os.path.abspath(to_a(d['pacBioSystem']['pgDataDir'])), "dbstore")

    port = int(d['smrtflow']['db']['properties']['portNumber'])
    host = to_a(d['smrtflow']['db']['properties']['serverName'])

    password = to_a(d['smrtflow']['db']['properties']['password'])
    user = to_a(d['smrtflow']['db']['properties']['user'])

    return DbConfig(db_name, pg_data_dir, host, port, user, password)


def call_import_legacy_sqlite(sqlite_db_path, dbc):
    """:type dbc: DbConfig"""

    cmd = "bundler-migrate-legacy-config --legacy {q} -u {u} -p {p} -s {h} --port {t} -n {n}"
    _d = dict(q=sqlite_db_path, u=dbc.user, p=dbc.password, h=dbc.host, t=dbc.port, n=dbc.db_name)

    return _run_raise_on_failure(cmd.format(**_d))


def _run_cmd(cmd):
    log.info("Running cmd '{}'".format(cmd))
    out = subprocess.Popen(cmd, shell=True)
    out.wait()
    exit_code = out.returncode
    log.info("Completed command with exit code {}".format(exit_code))
    return exit_code


def _run_raise_on_failure(cmd):
    rcode = _run_cmd(cmd)
    if rcode != 0:
        raise RuntimeError("Command Failed")
    return rcode


def _is_running(db_config):
    """Check if Db is running"""
    rcode = db_status(db_config)
    return True if rcode == 0 else False


def _start_db_or_raise(dbc):
    """Start or raise if can't start the db"""
    was_started = _is_running(dbc)
    if not was_started:
        start_success = db_start(dbc)
        if not start_success:
            raise RuntimeError("Unable to start db successfully")

    return was_started


def _to_cmd(dbc, action):
    """:type dbc: DbConfig"""
    _d = dict(l="logfile", g=dbc.pg_data_dir, p=dbc.port, h=dbc.host, a=action)
    cmd = "pg_ctl {a} --log \"{l}\" -w --pgdata {g} -o \"-p {p} -h {h}\"".format(**_d)
    return cmd


def _fix_postgres_config(path, var_run_dir):
    # workaround for config having references to /var/run/postgresq depending
    # on how it was installed
    if not os.path.exists(var_run_dir):
        os.mkdir(var_run_dir)
    # overwrite the `unix_socket_directories` value
    with open(path, 'a') as f:
        f.write("# Custom override\n")
        f.write("unix_socket_directories = '{}'\n".format(var_run_dir))
    return var_run_dir


def db_init(dbc):
    """Fresh/clean initialization of the database

    1. Create pg data dir (if necessary)
    2. call initdb (this will raise if the db already exists)

    :type dbc: DbConfig
    """
    def to_p(x):
        return os.path.join(dbc.pg_data_dir, x)

    root_dir = dbc.pg_data_dir
    if not os.path.exists(root_dir):
        os.mkdir(root_dir)

    # write the password to tmp file
    t = tempfile.NamedTemporaryFile().name
    with open(t, 'w+') as f:
        f.write(dbc.password)

    _d = dict(g=dbc.pg_data_dir, u=dbc.user, t=t)
    cmd = "initdb --pgdata {g} --username {u} --pwfile={t}".format(**_d)

    rcode = _run_cmd(cmd)

    # see comments above. Perhaps this should be removed
    _fix_postgres_config(to_p("postgresql.conf"), to_p("var-run"))

    if os.path.exists(t):
        os.remove(t)
    return rcode


def db_create(dbc):
    """Will create a postgres SL db

    :type dbc: DbConfig
    """

    was_started = _is_running(dbc)
    _start_db_or_raise(dbc)

    # TODO. Add check for previously created tables. Is this necessary or just let createdb fail?
    _d = dict(p=dbc.port, h=dbc.host, g=dbc.pg_data_dir, d=dbc.db_name)
    cmd = "createdb --echo --port {p} --host {h} {d}".format(**_d)
    rcode = _run_cmd(cmd)

    # Now create a user
    _x = dict(u=dbc.user)
    cmd = "createuser --echo --createdb --superuser {u}".format(**_x)
    if rcode == 0:
        _run_cmd(cmd)

    # if the db was original running, keep it running, otherwise, shut it down
    if not was_started:
        db_stop(dbc)

    return rcode


def db_start(dbc):
    """:type dbc: DbConfig"""
    return _run_cmd(_to_cmd(dbc, "start"))


def db_stop(dbc):
    """:type dbc: DbConfig"""
    if _is_running(dbc):
        return _run_cmd(_to_cmd(dbc, "stop"))
    else:
        log.info("Database is not running. No stopping action necessary")
        return 0


def db_status(dbc):
    """Get the Status of the Database

    :type dbc: DbConfig
    """
    _d = dict(g=dbc.pg_data_dir, h=dbc.host, p=dbc.port)
    cmd = "pg_ctl status --silent --pgdata {g} -o \"-p {p}\"".format(**_d)
    return _run_cmd(cmd)


def db_migrate(dbc, sqlite_db_path, migration_json):
    """

    1. Load legacy-migration.json (if exists)
    2. Call legacy importing tool
    3. Write Legacy Migration JSON

    :type dbc: DbConfig
    """
    was_successful = False

    if os.path.exists(migration_json):
        d = json.load(open(migration_json))
        m = Migration.from_d(d)
        if m.was_successful:
            log.debug("Migration was successful. Skipping {}".format(m))
            was_successful = True
        else:
            # Try migration again?
            sys.stderr.write("Retries of a FAILED migration/import of a legacy SQLITE db is not supported\n")
            was_successful = False
    else:
        # Try a new importing
        was_started = _is_running(dbc)
        _start_db_or_raise(dbc)

        try:
            _ = call_import_legacy_sqlite(sqlite_db_path, dbc)
            comment = "Successfully imported legacy data"
            m = Migration(True, datetime.datetime.now(), sqlite_db_path, comment)
            was_successful = True
        except Exception as e:
            comment = "Failed to import legacy data. {}".format(e)
            m = Migration(False, datetime.datetime.now(), sqlite_db_path, comment)

        m.write(migration_json)

        # shutdown the db if it was not originally started
        if not was_started:
            db_stop(dbc)

    return was_successful


def main(argv=None):
    args = sys.argv[1:] if argv is None else argv[1:]

    p = get_parser()
    logging.basicConfig(file=sys.stdout, level=logging.DEBUG)

    pargs = p.parse_args(args)
    return pargs.func(pargs)


if __name__ == '__main__':
    sys.exit(main(argv=sys.argv))
