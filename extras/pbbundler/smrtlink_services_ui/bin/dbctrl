#!/bin/bash
# ---- error handling
set -o errexit;
set -o posix;
set -o pipefail;
set -o errtrace;
set -o nounset;

# Primary Author: Herb Maeder
# Migration of code from perforce (http://swarm/files/depot/software/smrtanalysis/bbmig/build/smrtlink/admin/bin/dbctl)


unexpected_error() {
    local errstat=$?
    echo "${g_prog:-$(basename $0)}: Error! Encountered unexpected error at 'line $(caller)', bailing out..." 1>&2
    exit $errstat;
}
trap unexpected_error ERR;

# ---- error functions

merror() {
    echo "$g_prog: Error! ""$@" 1>&2;
    exit 1;
}
minterror() {
    echo "$g_prog: Internal Error! ""$@" 1>&2;
    exit 1;
}
mwarn() {
    echo "$g_prog: Warning! ""$@" 1>&2;
}

# ---- usage

usage() {
  local exitstat=2;
  if [[ ! -z "${2:-}" ]] ; then
      if [[ ! $2 =~ [[:digit:]]+ ]] ; then
	   minterror "usage(): exitstat ($2) must be numeric."
      fi
      exitstat=$2;
  fi

  # Only redirect to stderr on non-zero exit status
  if [[ $exitstat -ne 0 ]] ; then
      exec 1>&2;
  fi

  if [[ ! -z "${1:-}" ]] ; then
      echo "$g_prog: Error! $1"
  fi

  echo "Usage: $g_prog [--help] --start"
  echo "       $g_prog [--help] --stop"
  echo "       $g_prog [--help] --init"
  echo "       $g_prog [--help] --status"
  echo "       $g_prog [--help] --dbcmd --|--dbcmdargs [args [args]...] "
  echo ""
  echo "         --start        -- start database server"
  echo "         --stop         -- stop database server"
  echo "         --init         -- initialize database dir"
  echo "         --status       -- show status of the database server"
  echo "         --dbcmd        -- run postgres executable"
  echo "         --|--dbcmdargs -- all remaining args passed to pgcmd "
  echo ""
  echo "         -h|--help     -- print this usage";
  echo "";


  if [[ $exitstat -ne 0 ]] ; then
      # Print error again, useful for long usages messages
      if [[ ! -z "${1:-}" ]] ; then
	  echo ""
	  echo "$g_prog: Error! $1"
      fi
  fi

  # bash only:
  if [[ $exitstat -ne 0 ]] ; then
      echo "  at: $(caller)";
  fi
  exit $exitstat;
}

# ---- argument parsing

achk() {
    if [[ $1 -eq 0 ]] ; then usage "Missing argument to $2 option"; fi
}

parseargs() {
    opt_start=false;
    opt_stop=false;
    opt_init=false;
    opt_status=false;
    opt_create=false;
    opt_migrate=false;
    opt_dbcmd="";
    opt_dbcmdargs=();
    while [[ $# != 0 ]]; do
	opt="$1"; shift;
	case "$opt" in
	    # Flag with no argument example:
	    #   --flag|--fla|--fl|--f)
	    #     opt_flag=true;;
	    # Option with argument example:
	    #   --arg|--ar|--a)
	    #     achk $# $opt; opt_somearg=$1; shift;;
	    --start) opt_start=true;;
	    --stop) opt_stop=true;;
	    --init) opt_init=true;;
	    --status) opt_status=true;;
	    --create) opt_create=true;;
	    --migrate) opt_migrate=true;;
	    --dbcmd)  achk $# $opt; opt_dbcmd=$1; shift;;
	    --|--dbcmdargs)  opt_dbcmdargs=${1+"$@"}; break;;
	    -h|-help|--help|--hel|--he|--h) usage "" 0;;
	    -*) usage "Unrecognized option: $opt";;
	    *)
		local argstr=${1+"$@"};
		usage "Unexpected extraneous arguments detected: $opt $argstr"
		;;
	esac
    done

    if [[ ! ${opt_start}${opt_stop}${opt_init}${opt_status}${opt_dbcmd:+true} =~ true ]] ; then
	usage "Must specify one of --start, --stop, --init, --status or --dbcmd"
    elif [[ ${opt_start}${opt_stop}${opt_init}${opt_status}${opt_dbcmd:+true} =~ true.*true ]] ; then
	usage "Must specify only one of --start, --stop, --init, --status or --dbcmd"
    fi
}

# ---- globals

set_preglobals() {
    g_prog=$(basename $0);
    g_progdir=$(dirname $0);
    g_progdir_abs=$(readlink -f "$g_progdir");
    g_tools_bin=$(readlink -f "${g_progdir}/../tools/bin")
    g_config=$(readlink -f "${g_progdir}/../smrtlink-system-config.json");

    # The path to Legacy Sqlite file. This should have a single key of {PB_DB_URI: /path/to/file.db }
    # Should we use this file to also store the status of the migration?
    #g_legacy_db_config=$(readlink -f "${g_progdir}/../legacy-db.json")
    # Fail this to make this explicit that this isn't yet supported
    g_sqlite_database="${g_progdir}/LEGACY-NOT-SUPPORTED"
}


# ---- subroutines

read_config() {
    # get key from smrtlink-system-config.json
    # Is there a cleaner way to do this?
    # I think we need a thin scala tool to do this. If a path is returned it should be absolute/resolved?
    # with get-value <KEY> <OPTIONAL_DEFAULT> (to handle Option[T]) values
    # Example, get-value smrtflow.server.host "http://my-host"

    logDir=$(python -c "import json,os,sys; d=json.load(open(sys.argv[1])); print os.path.abspath(d['pacBioSystem']['logDir'])" ${g_config})

    g_db_logfile="${logDir}/dbctrl.log"

    g_db_datadir=$(python -c "import json,os,sys; d=json.load(open(sys.argv[1])); print os.path.abspath(d['pacBioSystem']['pgDataDir'])" ${g_config})

    g_db_port=$(python -c "import json,os,sys; d=json.load(open(sys.argv[1])); print int(d['smrtflow']['db']['properties']['portNumber'])" ${g_config})

    g_db_host=$(python -c "import json,os,sys; d=json.load(open(sys.argv[1])); print d['smrtflow']['db']['properties']['serverName']" ${g_config})
    # raw password
    g_db_user=$(python -c "import json,os,sys; d=json.load(open(sys.argv[1])); print d['smrtflow']['db']['properties']['password']" ${g_config})
    g_db_password=$(python -c "import json,os,sys; d=json.load(open(sys.argv[1])); print d['smrtflow']['db']['properties']['user']" ${g_config})

    g_db_database_smrtlink=$(python -c "import json,os,sys; d=json.load(open(sys.argv[1])); print d['smrtflow']['db']['properties']['databaseName']" ${g_config})

    # This shows how the password md5 is computed.  Not really needed for this
    # temporary solution, since we are hardwiring the password anyway.
    g_db_password_md5="md5"$(echo -n "${g_db_password}${g_db_user}" | md5sum | sed -e 's/[[:space:]].*//')
}

db_start() {
    echo "Starting database server..."
    local datestr
    datestr=$(echo $(date +"%s")": "$(date))
    echo "===== Starting database: $datestr" >> "$g_db_logfile"
    local stat=0;
    pg_ctl -l "$g_db_logfile" -w -D "$g_db_datadir" -o "-k '' -p $g_db_port -h $g_db_host" start || stat=$?
    if [[ $stat -ne 0 ]] ; then
	echo "Logfile Output:"
	sed -ne "/^===== Starting database: ${datestr%%:*}/,\$p" "$g_db_logfile"
	merror "Error detected in starting database server";
    fi
    exit $stat;
}
db_stop() {
    # FIXME: should we do a dbbackup here?

    echo "Stopping database server..."
    exec pg_ctl -w -D "$g_db_datadir" -o "-p $g_db_port" stop
}
db_init() {

    echo "Initializing database data dir..."
    local stat=0;
    ( set +o posix; pg_ctl -D "$g_db_datadir" -o "-U $g_db_user --auth-host=md5 --auth-local=reject --pwfile="<(echo "$g_db_password_md5") init ) || stat=$?
    exit $stat;
}

db_create() {
    # This was migrated from apply_settings_database from installerprompt

    # This will

    # This must be called after apply_smrtslag_settings_configjson(), since
    # the <smrtslagroot>/bin/upgrade script depends on the json config files
    # existing in order to set up the database.

    echo "Attempting to create database (if necessary) with data dir '${g_db_datadir}'"


    if [[ -e "$g_topdir/bundles/smrtlink-analysisservices-gui/current/private/pacbio/smrtlink-analysisservices-gui/bin/upgrade" ]] &&
	! sed -ne '$p' smrt400/install/smrtlink-incremental_4.1.0.00479/bundles/smrtlink-analysisservices-gui/install/smrtlink-analysisservices-gui-fromsrc_4.1.0.00160/private/pacbio/smrtlink-analysisservices-gui/bin/upgrade |grep -q 'NOT IMPLEMENTED'; then

        # Call the smrtlink services bundler upgrade.  This will initialize
        # the postgres database from scratch (including setting up ports, and
        # credentials), create the smrtlink database, import the old sqlite.db
        # database, and initially populate the smrtlinkdb database.
        # All control of the database including backups and such will be part
        # of the services bundle now.
        "${g_progdir}/upgrade"
    else
        # Create the database datastore and backup directories
        if [[ ! -e "$g_dbdatadir_dbdatastore_dir" ]] ; then
            mkdir -p "$g_dbdatadir_dbdatastore_dir"
        fi
        if [[ ! -e "$g_dbdatadir_dbbackup_dir" ]] ; then
            mkdir -p "$g_dbdatadir_dbbackup_dir"
        fi

        # Determine if we need to initialize the database
        local emptydir;
        emptydir=$( find "$g_dbdatadir_dbdatastore_dir" -maxdepth 0 -type d -empty || true)
        if [[ ! -z "$emptydir" ]] ; then
            echo "    Initializing the database..."
            db_init
        fi

        # FIXME: do we need to make a backup of the database?
        # "$g_progdir/dbbackup"

        # Start database
        if "$g_progdir/dbctl" --status >> "$g_db_logfile" ; then
            # Stop database server if it is running (could have changed database
            # directory or something like that).
            db_stop
        fi
        echo "    Starting the database server..."
        db_start

        # Database server is stopped.  Trap any exit, and try to stop the
        # database in order to leave us in the same state we started in.
        exittrap() {
            echo "  Exiting unexpectedly, Stopping the database server..."
            db_stop || true
        }
        trap exittrap EXIT;


        local dblist_str;
        # Query for a list of databases in table form.  Do this in a separate
        # line than the grep to make it clear if we happen to get an error in
        # the actual query (vs match/non-match status from grep)
        dblist_str=$("$g_progdir/dbctl" --dbcmd psql -- -lqtA )
        if ! echo "$dblist_str" | grep -q -E "^${g_db_database_smrtlink}\|" ; then
            echo "      Creating '$g_db_database_smrtlink' database..."
            "$g_progdir/dbctl" --dbcmd createdb -- "$g_db_database_smrtlink" >> "$g_db_logfile" ;
        else
            "Found existing created database ${g_db_database_smrtlink}. Skipping creation"
        fi

        # FIXME(mpkocher)(This tool should really have a subparser to validate or validation + apply Postgres migrations
        echo "      Validating and populating '$g_db_database_smrtlink' database..."
        ${g_tools_bin}/smrt-db-tool -u "$g_db_user" -p "$g_db_password" -s "$g_db_host" --port "$g_db_port" -n "$g_db_database_smrtlink"  >> "$g_db_logfile"

        # Unset the exittrap to stop the database server.  The next thing we will
        # do is stop the server (if it fails, we don't need to try to stop it
        # again).
        trap - EXIT;
        unset -f exittrap;

        # Stop database
        echo "    Stopping the database server..."
        db_stop
    fi
}


# Import the legacy Sqlite database into Postgres. This assumes the database has been created and is up and running.
db_migrate() {

    if [[ -e "$g_sqlite_database" ]] ; then
        local stat=0
		echo "      Attempting to Importing legacy Sqlite database to Postgres DB"
		${g_tools_bin}/bundler-migrate-legacy-config --legacy "$g_sqlite_database" -u "$g_db_user" -p "$g_db_password" -s "$g_db_host" --port "$g_db_port" -n "$g_db_database_smrtlink" >> "$g_db_logfile" || stat=$?

		if [[ $stat -ne 0 ]] ; then
		    merror "Could not import sqlite database to postgresql"
		else
            # Double check that the import happened ok
            local import_outstr;
            stat=0;
            import_outstr=$("$g_tools_bin/bundler-migrate-legacy-config" --legacy "$g_sqlite_database" -u "$g_db_user" -p "$g_db_password" -s "$g_db_host" --port "$g_db_port" -n "$g_db_database_smrtlink" >> "$g_db_logfile" ) || stat=$?
            if [[ $stat -ne 0 ]] ; then
                minterror "Unexpected error from sqlite->postgres import tool, expected to be already imported"
            fi
            if [[ $import_outstr =~ already\ migrated\ string ]] ; then
                local datestr;
                datestr=$( date +"%Y%m%d_%H%M%S" )
                mv "$g_sqlite_database" "${g_sqlite_database}.migrated.${datestr}"
            fi
		    fi
	else
        echo "Unable to find sqlite file ${g_sqlite_database}. Skipping importing step"
	fi
}

# Get the db status given the db config defined in smrtlink-system-config.json
db_status() {
    exec pg_ctl -s -D "$g_db_datadir" -o "-p $g_db_port" status
}

# Run any command from an exe in the postgresql bin/exe tools
db_dbcmd() {
    local stat=0;
    PGPASSWORD="$g_db_password" exec "$opt_dbcmd" -p "$g_db_port" -h "$g_db_host" -U "$g_db_user" "${opt_dbcmdargs[@]+${opt_dbcmdargs[@]}}"
}

# ---- main

# Save off original cmdline args, use as "${g_origargs[@]}" (with doublequotes)
g_origargs=( ${1+"$@"} )

set_preglobals ${1+"$@"};
parseargs ${1+"$@"};

read_config;

if $opt_start; then
    db_start;
elif $opt_stop; then
    db_stop;
elif $opt_init; then
    db_init;
elif $opt_status; then
    db_status;
elif ${opt_create}; then
    db_create
elif [[ ! -z "$opt_dbcmd" ]]; then
    db_dbcmd;
else
    minterror "Unknown action, specify --start, --stop, --init, --create or --status".
fi