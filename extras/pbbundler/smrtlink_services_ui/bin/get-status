#!/usr/bin/env python

import os
import pprint
import socket
import urllib2
import ssl
import json
import logging
import sys
import time
import argparse
import itertools
from collections import namedtuple

log = logging.getLogger(__name__)

__author__ = "M. Kocher"
__version__ = '0.3.0'

_LOG_FORMAT = '[%(levelname)s] %(asctime)-15s %(message)s'

_BUNDLE_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
_CONFIG_JSON = os.path.join(_BUNDLE_ROOT, 'smrtlink-system-config.json')

LOG_LEVELS = {
    "DEBUG": logging.DEBUG,
    "INFO": logging.INFO,
    "ERROR": logging.ERROR,
    "WARN": logging.WARN
}

MAX_DEFAULT_RETRIES = 3

C = namedtuple("C", "idx name")


class Constants(object):
    """SubComponent Ids"""
    SL_ANALYSIS = C("smrtlink-analysis", "SMRT Link Analysis Services")
    TOMCAT = C("tomcat", "SL tomcat UI Webserver")
    WSO2 = C("wso2", "WSO2 API Manager")
    SVIEW = C("smrtview", "SMRT View")

    ALL = (SL_ANALYSIS, TOMCAT, WSO2, SVIEW)


class SubComponent(object):
    def __init__(self, component, urls, max_retries=MAX_DEFAULT_RETRIES):
        """Thin model for encapsulating a SL Subcomponent, such as WSO2 and a list of test/status URLs"""
        self.component = component
        self.urls = urls
        # Max number of retires per url call
        self.max_retries = max_retries

    def __repr__(self):
        _d = dict(k=self.__class__.__name__, c=self.component, u=self.urls)
        return "<{k} component:{c} urls: {u} >".format(**_d)


def get_parser():
    desc = "Check the status of the SMRT Services"
    p = argparse.ArgumentParser(version=__version__,
                                description=desc,
                                formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    f = p.add_argument
    f('--max-retries', type=int, default=MAX_DEFAULT_RETRIES, help="Number of retries")
    f('--sleep-time', type=int, default=5, help="Sleep time between retries (in sec)")
    f('--debug', action='store_true', default=False, help="Shortcut to enable DEBUG log level")
    f('--log-level', default=None, choices=LOG_LEVELS.keys(),
      help="Set log level (--debug will override this value if supplied)")
    f('--log-file', default=None,
      help="Custom path to log file output. Default will output to the location defined in the "
           "smrtlink-system-config.json file.")
    f('-i', '--subcomponent-id', default=None, choices=list(x.idx for x in Constants.ALL),
      help="Only get the status of SL Subcomponent")
    return p


# Keep this in sync with apply-config
class ConfigConstants(object):
    # Make a call to ws02 to make sure it started up correctly
    # https://localhost:9443/publisher
    WS02_PORT = 9443
    WS02_STATUS_ENDPOINT = "publisher"


def _load_config():
    with open(_CONFIG_JSON, 'r') as f:
        d = json.loads(f.read())
    return d


def _https_url_opener(url):
    # this enables support for https calls
    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    opener = urllib2.build_opener(urllib2.HTTPSHandler(context=ctx))
    return opener.open(url)


def _get_opener(url):
    if url.startswith("http://"):
        return urllib2.urlopen(url)
    else:
        return _https_url_opener(url)


def _check_status_or_raise(url, prefix_msg=None, log_results=False, writer=sys.stdout.write):
    msg = "checking {u}".format(u=url)
    if prefix_msg is not None:
        msg = " ".join([prefix_msg, msg])
        log.debug(msg)

    x = _get_opener(url)
    datum = x.read()
    if log_results:
        log.info(datum)
    x.close()
    log.debug("Successfully reached {u}".format(u=url))
    return True


def stderr_writer(line):
    sys.stderr.write(line + "\n")


def null_writer(line):
    pass


def _check_status(url, prefix_msg=None, writer=stderr_writer):

    m = "" if prefix_msg is None else prefix_msg
    try:
        return _check_status_or_raise(url, prefix_msg=m)
    except urllib2.URLError as e:
        # log.exception(e)
        writer(m + "Failed to connect to {u}".format(u=url))
        return False
    except Exception as e:
        writer(m + "Failed to make request to {u}\n{e}".format(u=url, e=e.message))
        return False


def _check_with_retry(url, ntries, sleep_time_sec=1):

    status = False
    n = 0
    while n < ntries:
        m = n + 1
        if m == ntries:
            prefix_msg = "FAILED Retry attempt {i} ".format(i=m)
            writer = stderr_writer
        else:
            prefix_msg = "WARNING Attempt {i} ".format(i=m)
            writer = stderr_writer

        state = _check_status(url, prefix_msg=prefix_msg, writer=writer)

        if state is True:
            status = True
            break
        time.sleep(sleep_time_sec)
        n += 1

    return status


def _to_url(host, port, prefix="http://"):
    if not host.startswith(prefix):
        host = prefix + host
    return ":".join([host, str(port)])


def get_subcomponent_status(subcomponent, max_retries=MAX_DEFAULT_RETRIES, sleep_time_sec=1):
    """
    Returns a successful message or raises. Any errors or warnings will be written to stderr.

    :type subcomponent: SubComponent
    :rtype: str
    """
    nurls = len(subcomponent.urls)
    name = subcomponent.component.name

    state = False
    log.debug("Subcomponent {c}: Attempting to get status with {n} test URLs".format(c=name, n=nurls))
    for i, url in enumerate(subcomponent.urls):
        emsg = "Subcomponent {c}: Failed to get status of {u}\n".format(c=name, u=url)
        try:
            state = _check_with_retry(url, max_retries, sleep_time_sec)
            if state:
                log.debug("Subcomponent {c} successfully status ({i}/{n}) of {u}\n".format(c=name, u=url, n=nurls, i=i))
            else:
                sys.stderr.write(emsg)
                return state
        except Exception as e:
            log.error(e)
            sys.stderr.write(emsg)
            return False

    if state:
        sys.stdout.write("Subcomponent {c} SUCCESSFUL status of {n} test URLs\n".format(c=name, n=nurls))
    return state


def get_status(host, tomcat_port, analysis_port, wso2_port, smrtview_port, max_retries=MAX_DEFAULT_RETRIES, sleep_time_sec=1, filter_subcomponent_func=None):
    """
    Check analysis service status, dataset types and jobs types. Check tomcat
    to verify UI code was loaded

    subcomponent_filter_func = (f: SubComponent) => bool

    :return: status
    :rtype: bool
    """

    tcat_url = _to_url(host, tomcat_port) + "/sl/"
    sl_analysis_url = _to_url(host, analysis_port)
    smrtview_url = _to_url(host, smrtview_port)

    services_url = sl_analysis_url + "/status"

    ds_types = ('subreads', 'references', 'hdfsubreads', 'alignments', 'barcodes')

    ds_urls = [sl_analysis_url + '/secondary-analysis/datasets/{f}'.format(f=f) for f in ds_types]

    job_types = ('pbsmrtpipe', 'convert-fasta-reference', 'import-dataset', 'merge-datasets')
    job_urls = [_to_url(host, analysis_port) + "/secondary-analysis/job-manager/jobs/{f}".format(f=f) for f in job_types]

    sl_urls = [[services_url], ds_urls, job_urls]
    sl_analysis_subcomponent = SubComponent(Constants.SL_ANALYSIS, list(itertools.chain(*sl_urls)), max_retries=max_retries)

    # SMRT View
    smrtview_urls = [smrtview_url + "/smrtview",
                     smrtview_url + "/smrtview/services/VersionService.VersionServiceHttpEndpoint/getVersion"]
    smrtview_subcomponent = SubComponent(Constants.SVIEW, smrtview_urls, max_retries=max_retries)

    # MK. Tomcat will lazily-load after the first request. Making an initial request
    # here to trigger (and **ignore** the response), then check the analysis services,
    # then check tomcat status.
    _check_status(tcat_url, writer=null_writer)

    wso2_publisher_url = _to_url(host, wso2_port, prefix="https://") + "/" + ConfigConstants.WS02_STATUS_ENDPOINT

    # FIXME(mpkocher)(2016-9-7). Roll out wso2 incrementally and tune this custom retry parameter
    wso2_subcomponent = SubComponent(Constants.WSO2, [wso2_publisher_url], max_retries=max_retries)

    tomcat_subcomponent = SubComponent(Constants.TOMCAT, [tcat_url], max_retries=max_retries)

    subcomponents = [sl_analysis_subcomponent, tomcat_subcomponent, smrtview_subcomponent, wso2_subcomponent]

    if filter_subcomponent_func is not None:
        subcomponents = [x for x in subcomponents if filter_subcomponent_func(x)]

    for subcomponent in subcomponents:
        state = get_subcomponent_status(subcomponent, max_retries=subcomponent.max_retries, sleep_time_sec=sleep_time_sec)
        if state is False:
            return False

    return True


def run_main(c, max_retries, sleep_time_sec, subcomponent_ids=None):

    server_d = c['smrtflow']['server']

    # Assume that the exe is called on that machine
    h = server_d.get('dnsName', None)
    if h is None:
        sys.stderr.write("WARNING host is assumed to be localhost.\n")
    host = "localhost" if h is None else h

    sl_analysis_port = server_d['port']

    system_d = c['pacBioSystem']

    tomcat_port = system_d['tomcatPort']

    smrt_view_port = system_d['smrtViewPort']

    # should this be exposed in the config.json ?
    wso2_port = ConfigConstants.WS02_PORT

    # Base SL Analysis Service URL
    url = _to_url(host, sl_analysis_port)

    if subcomponent_ids is None:
        filter_func = lambda x: True
    else:
        filter_func = lambda x: x.component.idx in subcomponent_ids

    status = get_status(host,
                        tomcat_port,
                        sl_analysis_port,
                        wso2_port,
                        smrt_view_port,
                        max_retries=max_retries,
                        sleep_time_sec=sleep_time_sec,
                        filter_subcomponent_func=filter_func)

    if status is True:

        names_d = {c.idx: c.name for c in Constants.ALL}
        if subcomponent_ids is None:
            component_filter = lambda x: True
        else:
            component_filter = lambda x: x.idx in subcomponent_ids

        component_ids = [c.idx for c in Constants.ALL if component_filter(c)]

        names = [names_d[c_id] for c_id in component_ids]
        msg = "SUCCESSFUL status of {n} SL subcomponent(s): {c}".format(n=len(names), c=", ".join(names))

        log.info(msg)
        sys.stdout.write(msg + "\n")

    return 0 if status is True else 1


def setup_logger(alog, level=logging.INFO, file_name=None,
                 log_filter=None,
                 str_formatter='[%(levelname)s] %(asctime)-15s [%(name)s %(funcName)s %(lineno)d] %(message)s'):
    """
    Because we want to log to the output dir defined in the smrtlink-system-config, the logging config
    needs to be delayed until after the config is parsed.

    :param alog: a log instance
    :param level: (int) Level of logging debug
    :param file_name: (str, None) if None, stdout is used, str write to file
    :param log_filter: (LogFilter, None)
    :param str_formatter: (str) log formatting str
    """

    alog.setLevel(logging.DEBUG)
    alog.propagate = 0

    if file_name is None:
        handler = logging.StreamHandler(sys.stdout)
    else:
        handler = logging.FileHandler(file_name)

    formatter = logging.Formatter(str_formatter)
    handler.setFormatter(formatter)
    handler.setLevel(level)

    if log_filter:
        handler.addFilter(log_filter)

    alog.addHandler(handler)

    return alog


def main(argv=sys.argv):

    p = get_parser()
    args = p.parse_args(argv)

    log_level_stdout = logging.WARN
    log_level_file = logging.INFO

    if args.log_level is not None:
        log_level_stdout = LOG_LEVELS[args.log_level]
        log_level_file = LOG_LEVELS[args.log_level]

    if args.debug:
        log_level_stdout = logging.DEBUG
        log_level_file = logging.DEBUG

    subcomponent_ids = None
    if args.subcomponent_id is not None:
        subcomponent_ids = (args.subcomponent_id, )

    max_retries = args.max_retries
    sleep_time_sec = args.sleep_time
    c = _load_config()

    log_dir = c['pacBioSystem']['logDir']

    if args.log_file is None:
        get_status_log = os.path.join(os.path.abspath(log_dir), "get-status.log")
    else:
        get_status_log = os.path.abspath(os.path.expanduser(args.log_file))

    # Because we want to log to the output dir defined in the smrtlink-system-config, the logging config
    # needs to be delayed until after the config is parsed.

    # SL System log dir
    setup_logger(log, log_level_file, file_name=get_status_log)

    # Stdout logger, This should probably have a higher default level
    setup_logger(log, log_level_stdout, file_name=None, str_formatter=_LOG_FORMAT)

    log.debug(args)

    log.debug("Loaded config")
    log.debug("\n" + pprint.pformat(c))

    return run_main(c, max_retries, sleep_time_sec, subcomponent_ids=subcomponent_ids)


if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
