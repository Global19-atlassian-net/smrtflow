package com.pacbio.secondary.common.model;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import com.pacbio.secondary.common.util.Iso8601Date;

/**
 * Simple API to read the metadata.rdf file generated by SMRT Pipe.
 * Although it can be re-written as xml, it does NOT serialize as rdf. 
 */
@XmlType(propOrder = {"title", "whenCreated", "jobState", "reference", "inputs",
		"reportGroups", "reportTitles", "dataGroups", "dataTitles", 
		"auxiliaryFiles", "measuredValues"})
public class MetadataRdf {
	
	private final static Logger LOGGER = Logger.getLogger(MetadataRdf.class
			.getName());
	
	public final static String FILE_NAME = "metadata.rdf";
    public final static String SMRTOWN_NS = "http://www.pacificbiosciences.com/SMRT.owl#";
    public final static String RDF_NS = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    public final static String DC_NS = "http://purl.org/dc/elements/1.1/";
    public final static String DCTERMS_NS = "http://purl.org/dc/terms/";
    
    private Document document;
	private String jobId;
	
	/**
	 * Non-public constructor wrapping an xml document.
	 * @param jobId 
	 */
	protected MetadataRdf(Document document, Integer jobId) {
		if( jobId == null )
			throw new RuntimeException( "jobId cannot be null" );
		this.document = document;
		this.jobId = String.format("%06d", jobId);
	}
	
	/**
	 * Constructor to open a metadata rdf file. Constructor closes the
	 * inputStream.
	 * 
	 * @param file
	 */
	public static MetadataRdf open(InputStream in, Integer jobId) throws IOException {
		if (in == null)
			return null;

		Document document = null;
		try {
			document = DocumentBuilderFactory.newInstance()
					.newDocumentBuilder().parse(in);
		} catch (Exception e) {
			throw new IOException("Failed to parse xml document", e);
		} finally {
			in.close();
		}
		return new MetadataRdf(document, jobId);
	}

	/**
	 * Job title.
	 */
	public String getTitle() {
		Element e = getNodeByAttribute( document, "rdf:about", jobId);
		return getNodeValue(e, "dc:title");
	}

	/**
	 * When the metadata file was created.
	 * @return date or null if missing or parsing failed
	 */
	public Date getWhenCreated() {
		Date date = null;
		String value = getNodeValue("dcterms:created");
		if (value != null) {
			try {
				date = Iso8601Date.parse(value);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}
		return date;
	}
	
	/**
	 * Job state, such as Completed or Failed.
	 */
	public JobState getJobState() {
		JobState state = null;
		NodeList nodes = document.getElementsByTagName("smrtowl:hasJobState");
		if (nodes != null && nodes.getLength() > 0) {
			String id = ((Element)nodes.item(0)).getAttribute("rdf:nodeID");
			Element el = getNodeByAttribute(document, "rdf:nodeID", id);
			if (el != null)
				state = new JobState(getNodeValue(el, "smrtowl:secondaryAnalysisJobState"),
									 getNodeValue(el, "smrtowl:secondaryAnalysisErrorMessage"));
		}
		return state;
	}
	
	/**
	 * URL for the reference sequence. 
	 */
	public String getReference() {
		return getNodeValue("smrtowl:usesReference");
	}
	
	/**
	 * The log file.
	 */
	public Link getAnalysisLog() {
		Link link = null;
		NodeList nodes = document.getElementsByTagName("smrtowl:hasAnalysisLog");
		if (nodes != null && nodes.getLength() > 0) {
			String id = ((Element)nodes.item(0)).getAttribute("rdf:resource");
			Element el = getNodeByAttribute(document, "rdf:about", id);
			if (el != null)
				link = new Link(getNodeValue(el, "smrtowl:local"), 
						   		getNodeValue(el, "dc:format"));
		}
		return link;
	}
	
	/**
	 * Get auxiliary files, like the log, visualization file, etc.
	 * @return list of all auxiliary files
	 */
	public List<Link> getAuxiliaryFiles() {
		List<Link> links = new ArrayList<Link>();
		NodeList nodes = document.getElementsByTagName("smrtowl:hasAuxiliaryFile");
		if (nodes != null) {
			for (int i = 0; i < nodes.getLength(); ++i) {
				String id = ((Element)nodes.item(i)).getAttribute("rdf:resource");
				Element el = getNodeByAttribute(document, "rdf:about", id);
				if (el != null)
					links.add(new Link(getNodeValue(el, "smrtowl:local"), 
									   getNodeValue(el, "dc:format")));
			}
		}
		return links;
	}
	
	/**
	 * Info about SMRT Pipe data files
	 * @return non-null, possibly empty list of all data outputs
	 */
	public List<LinkTitle> getDataTitles() {
		return getLinkTitles("smrtowl:hasData", "smrtowl:inDataGroup");
	}
	
	/**
	 * Info about data files for a given title, such as "Variants"
	 * @param title the title of the data
	 * @return data entry matching the requested title
	 */
	public LinkTitle getDataTitle(String title) {
		if (title == null)
			throw new IllegalArgumentException("title cannot be null");
		for (LinkTitle lt : getDataTitles()) {
			if (title.equals(lt.getTitle()))
				return lt;
		}
		return null;
	}
	
	/**
	 * Info about reports
	 * @return list of all reports
	 */
	public List<LinkTitle> getReportTitles() {
		return getLinkTitles("smrtowl:hasReport", "smrtowl:inReportGroup");
	}
	
	/**
	 * Info about report files for a given report, such as "Filtering".
	 * @param title the title of the data
	 * @return data entry matching the requested title
	 */
	public LinkTitle getReportTitle(String title) {
		if (title == null)
			throw new IllegalArgumentException("title cannot be null");
		for (LinkTitle lt : getReportTitles()) {
			if (title.equals(lt.getTitle()))
				return lt;
		}
		return null;
	}
	
	/**
	 * All data groups and links.
	 */
	public List<Group> getDataGroups() {
		return toGroupArray(getDataTitles());
	}
	
	/**
	 * All report groups and links.
	 */
	public List<Group> getReportGroups() {
		return toGroupArray(getReportTitles());
	}
	
	/**
	 * Metrics.
	 */
	public List<MeasuredValue> getMeasuredValues() {
		List<MeasuredValue> list = new ArrayList<MeasuredValue>();
		NodeList nodes = document.getElementsByTagName("smrtowl:hasMeasuredValue");
		if (nodes != null) {
			for (int i = 0; i < nodes.getLength(); ++i) {
				String id = ((Element)nodes.item(i)).getAttribute("rdf:resource");
				Element el = getNodeByAttribute(document, "rdf:about", id);
				
				
				if (el != null) {
					
					String value = getNodeValue(el, "smrtowl:hasValue");
					if( value == null ) {
						//bug 15521 - control seq is null, skip null values
						continue;
					}
					
					list.add(new MeasuredValue(
							getNodeValue(el, "dc:title"), 
							value,
							id,
							getNodeValue(el, "smrtowl:isForReportsDisplay")));
				}
			}
		}
		return list;
	}
	
	public List<Input> getInputs() {
		List<Input> list = new ArrayList<Input>();
		NodeList nodes = document.getElementsByTagName("smrtowl:hasInput");
		if (nodes != null) {
			for (int i = 0; i < nodes.getLength(); ++i) {
				String id = ((Element)nodes.item(i)).getAttribute("rdf:nodeID");
				Element el = getNodeByAttribute(document, "rdf:nodeID", id);
				if (el != null)
					list.add(new Input(
							getNodeValue(el, "dc:format"), 
							getNodeValue(el, "smrtowl:local"),
							getNodeValue(el, "smrtowl:source"),
							getNodeValue(el, "smrtowl:sourceVersion")));
			}
		}
		return list;
	}
	
	/**
	 * Group links together by group name.
	 * @param linkTitles
	 * @return list of groups
	 */
	private List<Group> toGroupArray(List<LinkTitle> linkTitles) {
		Map<String,Group> nameGroupMap = new HashMap<String,Group>();
		List<Group> groups = new ArrayList<Group>();
		
		for (LinkTitle title : linkTitles) { 
			String name = title.getGroup();
			Group group = nameGroupMap.get(name);

			if (group == null) {
				group = new Group(name);
				groups.add(group);
				nameGroupMap.put(name, group);
			}
			
			group.getMembers().add(title);
		}
		return groups;
	}
	
	/**
	 * Get the text value of the first matching node.
	 * @param tagName element name
	 * @return text value of first match
	 */
	private String getNodeValue(String tagName) {
		return getNodeValue(document.getDocumentElement(), tagName);
	}
	
	/**
	 * Look up the value of a tag under an element.
	 * @param element
	 * @param tagName
	 * @return
	 */
	static String getNodeValue(Element element, String tagName) {
		String value = null;
		NodeList nodes = element.getElementsByTagName(tagName);
		if (nodes != null && nodes.getLength() > 0)
			value = nodes.item(0).getTextContent();
		
		if (value != null && value.isEmpty())
			value = null;
		return value;
	}
	
	/**
	 * Look up a node by attribute.
	 * @param attrName attribute name
	 * @param value value
	 * @return the element, or null if not found
	 */
	static Element getNodeByAttribute(Document document, String attrName, String value) {
		Element element = null;
		NodeList nodes = document.getElementsByTagName("rdf:Description");
		if (nodes != null) {
			for (int i = 0; i < nodes.getLength() && element == null; ++i) {
				Element e = (Element)nodes.item(i);
				if (e.hasAttribute(attrName) && value.equals(e.getAttribute(attrName)))
					element = e;			
			}
		}
		return element;
	}	
	
	/**
	 * Info about reports or data.
	 * @param groupName either smrtowl:inReportGroup or smrtowl:inDataGroup
	 * @return list of all files
	 */
	private List<LinkTitle> getLinkTitles(String tagName, String groupName) {
		List<LinkTitle> list = new ArrayList<LinkTitle>();
		NodeList nodes = document.getElementsByTagName(tagName);
		for (int i = 0; i < nodes.getLength(); ++i) {
			String id = ((Element)nodes.item(i)).getAttribute("rdf:nodeID");
			Element element = getNodeByAttribute(document, "rdf:nodeID", id);
			if (element != null) {
				list.add(new LinkTitle(document, element, groupName));
				LOGGER.fine( "Added LinkTitle: " + list );
			}
		}
		return list;
	}
	
	/**
	 * A secondary analysis job state supplied by SMRT Pipe.
	 */
	@XmlType(propOrder = {"state", "errorMessage"})
	public static class JobState {
		private String state;
		private String errorMessage;
		
		public JobState() {}
		
		/**
		 * Constructor.
		 * @param element containing job state and message
		 */
		public JobState(String state, String errorMessage) { 
			this.state = state;
			this.errorMessage = errorMessage;
		}

		public String getState() {
			return state;
		}
		
		public void setState(String state) {
			this.state = state;
		}
		
		public String getErrorMessage() {
			return errorMessage;
		}	
		
		public void setErrorMessage(String errorMessage) {
			this.errorMessage = errorMessage;
		}
	}
	/**
	 * Common structure to represent files like reports, data, logs, etc.
	 */
	@XmlType(propOrder = {"path", "format"})
	public static class Link {
		private String path; 
		private String format;
		
		public Link() {}
		
		/**
		 * Constructor.
		 * @param element
		 */
		public Link(String path, String format) {
			this.path = path;
			this.format = format;
		}

		public String getPath() {
			return path;
		}
		
		public void setPath(String path) {
			this.path = path;
		}

		public String getFormat() {
			return format;
		}
		
		public void setFormat(String format) {
			this.format = format;
		}
	}
	/**
	 * A data or report in the metadata rdf file, available in potentially multiple formats.
	 */
	@XmlType(propOrder = {"group", "title", "links"})
	public static class LinkTitle {
		private String group;
		private String title;
		private List<Link> links;
		
		public LinkTitle() {}
		
		/**
		 * Constructor.
		 * @param element xml node
		 */
		public LinkTitle(Document document, Element element, String groupName) {
			title = MetadataRdf.getNodeValue(element, "dc:title");
			group = MetadataRdf.getNodeValue(element, groupName);
			
			links = new ArrayList<Link>();
			NodeList nodes = element.getElementsByTagName("smrtowl:hasLink");
			if (nodes != null) {
				for (int i = 0; i < nodes.getLength(); ++i) {
					String id = ((Element)nodes.item(i)).getAttribute("rdf:resource");		
					Element res = MetadataRdf.getNodeByAttribute(document, "rdf:about", id);
					if (res != null)
						links.add(new Link(MetadataRdf.getNodeValue(res, "smrtowl:local"),
										   MetadataRdf.getNodeValue(res, "dc:format")));				
				}
			}
			links = Collections.unmodifiableList(links);
		}

		public String getGroup() {
			return group;
		}
		
		public void setGroup(String group) {
			this.group = group;
		}

		public String getTitle() {
			return title;
		}	
		
		public void setTitle(String title) {
			this.title = title;
		}

		@XmlElement(name = "link")
		public List<Link> getLinks() {
			if (links == null)
				links = new ArrayList<Link>();
			return links;
		}
		
		public String toString() {
			try {
				StringBuffer sb = new StringBuffer("{");
				boolean first = true;
				for (Method m : getClass().getDeclaredMethods()) {
					if (Modifier.isPublic(m.getModifiers())
							&& m.getName().startsWith("get")) {
						if( !first )
							sb.append(", ");
						
						String n = m.getName().replace("get", "");
						String t = n.substring(0, 1);
						String r = t.toLowerCase();
						
						sb.append( "\"").append(n.replace(t,r) + "\":"
								+ m.invoke(this, (Object[]) null) );
						first = false;
					}
				}
				return sb.toString();
			} catch (Exception e) {
				return super.toString();
			}
		}
	}
	
	/**
	 * A report group or data group.
	 */
	@XmlType(propOrder = {"name", "members"})
	public static class Group {
		private String name;
		private List<LinkTitle> members;
		
		public Group() {}
		
		public Group(String name) {
			this.name = name;
		}

		public String getName() {
			return name;
		}	
		
		public void setName(String name) {
			this.name = name;
		}
		
		@XmlElement(name = "members")
		public List<LinkTitle> getMembers() {
			if (members == null)
				members = new ArrayList<LinkTitle>();
			return members;
		}
	}
	
	/**
	 * A metric.
	 */
	@XmlType(propOrder = {"title", "value"})
	public static class MeasuredValue implements Comparable<MeasuredValue> {
		private String title;
		private String value;
		private String id;
		private boolean isForReportsDisplay = false;
		
		

		public MeasuredValue() { 			
		}
		
		
		public MeasuredValue(String title, String value, String id, String isForReportsDisplay) {
			this.title = title;
			this.value = value;
			this.id =id;
			if ( isForReportsDisplay != null )
				this.isForReportsDisplay = Boolean.parseBoolean(isForReportsDisplay);
		}
		
		public String getTitle() { 
			return title; 
		}
		
		public void setTitle(String title) { 
			this.title = title; 
		}
		
		public String getValue() { 
			return value; 
		}
		
		public void setValue(String value) { 
			this.value = value; 
		}

		public String getId() {
			return id;
		}

		public void setId(String id) {
			this.id = id;
		}
		
		public void setForReportsDisplay(boolean isForReportsDisplay) {
			this.isForReportsDisplay = isForReportsDisplay;
		}

		public boolean isForReportsDisplay() {
			return isForReportsDisplay;
		}		
		
		@Override
		public int compareTo(MeasuredValue o) {
			int c = String.valueOf(title).compareTo(String.valueOf(o.title));
			if (c == 0) {
				try {
					c = ((Double)Double.parseDouble(value))
						.compareTo(Double.parseDouble(o.value));
				} catch(NumberFormatException e) {
					// ignore
					c = String.valueOf(value).compareTo(String.valueOf(o.value));
				}
			}
			return c;
		}

		
	}
	
	@XmlType(propOrder = {"format", "path", "source", "sourceVersion"})
	public static class Input {
		private String format;
		private String path;
		private String source;
		private String sourceVersion;
		
		public Input() {			
		}
		
		public Input(String format, String path, String source,	String sourceVersion) {
			this.format = format;
			this.path = path;
			this.source = source;
			this.sourceVersion = sourceVersion;
		}

		public String getFormat() {
			return format;
		}
		
		public void setFormat(String format) {
			this.format = format;
		}
		
		public String getPath() {
			return path;
		}
		
		public void setPath(String path) {
			this.path = path;
		}
		
		public String getSource() {
			return source;
		}
		
		public void setSource(String source) {
			this.source = source;
		}
		
		public String getSourceVersion() {
			return sourceVersion;
		}
		
		public void setSourceVersion(String sourceVersion) {
			this.sourceVersion = sourceVersion;
		}
	}
}
